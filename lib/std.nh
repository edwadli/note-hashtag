include array
include io
include math

extern "support.hpp" "nh_support" "int_of_float" fun IntOfFloat float -> int
extern "support.hpp" "std" "to_string" fun StringOfFloat float -> string

extern "support.hpp" "nh_support" "float_of_int" fun FloatOfInt int -> float
extern "support.hpp" "std" "to_string" fun StringOfInt int -> string

extern "support.hpp" "nh_support" "shuffle" fun ShuffleInts int{} -> int{}
extern "support.hpp" "nh_support" "shuffle" fun ShuffleFloats float{} -> float{}

fun Ignore x = ()

type key_signature = {
  scale = { 261.63 293.66 329.63 349.23 392.00 440.00 493.88 }
}


type time_signature = {
  upper = 4
  lower = 4
}

type pitch = {
  rank = 1
  octave = 0
  offset = 0
}

type chord = {
  pitches = pitch{}
}

fun ChordOfPitch p = init chord { pitches = {p} }

fun PitchOfInt i = (
  if (i < 0) || (i > (Size key_sig$scale)) then (
    throw "Could not construct pitch from int";
    init pitch)
  else
    init pitch { rank = i }
)


fun AddPitchOctave p octaves = ( p$octave = p$octave + octaves; p)

fun AddPitchNum num p = (

  r = p$rank + num
  oct = 0
  size = Size key_sig$scale
  if r > size then (
    oct = r/size
    r = ((r-1) % size)
    r = r + 1 //edge case for r = 7
  )
  else(
    if r < 0 then (
      oct = (-r)/size - 1
      r = (r % size) + size
    )
    else
      ()
  )
    
  init pitch{rank = r; octave = (oct + p$octave); offset = p$offset}
)

fun AddChordNum num ch = (
  out_pitch = pitch{}
  for p in ch$pitches do
    out_pitch = out_pitch . {(AddPitchNum num p)}
  init chord{pitches = out_pitch}
)

fun PrintChord ch = (
  size = Size ch
  for c in ch do (
    x = c$pitches
    for p in x do
      Print (StringOfInt p$rank)
    Print "\n"
  )
)

fun PrintRhythms rh = (
  size = Size rh
  for r in rh do (
    Print (StringOfFloat r)
  )
)


type track = {
  key_sig = init key_signature
  time_sig = init time_signature
  chords = chord{}
  durations = float{}
  tempo = 120
  // currently we can only assign a single volume to the track
  // of dynamics control we lack
  // yes, it's a simplicity hack
  // but i'd like to hit the sack
  volume = 1.0
}

type song = {
  tracks = track{}{}
  volumes = float{}
}

fun IsMember l x = (
  mem = false
  for item in l do mem = (mem || (item == x))
  mem
)

fun Reverse_List l = (
  size = Size l
  if size < 2 then
    l
  else (
    out = [(l.(size-1))];
    for i in Range 2 (size+1) do
      out = out . [l.(size - i)]
    out
  ) 
)

fun FlatPitch p = ( p$offset = p$offset - 1; p )
fun SharpPitch p = ( p$offset = p$offset + 1; p )

fun ChordOfChords c1 c2 = (
  c = init chord
  for p in c1$pitches . c2$pitches
    do if IsMember c$pitches p then () else c$pitches = c$pitches . {p}
  c
)

fun Rest = init chord

fun ConcatTracks t1 t2 = (
  if t1$key_sig == t2$key_sig &&\
      t1$time_sig == t2$time_sig &&\
      t1$tempo == t2$tempo
  then (
    t1$chords = t1$chords . t2$chords
    t1$durations = t1$durations . t2$durations
    t1
  )
  else (throw "Cannot concat tracks with different key or time signature or tempo"; t1)
)

key_sig = init key_signature
time_sig = init time_signature
tempo = 120

fun ZipSame f c = (
  if (Size f) != (Size c) then
    (throw "Cannot Zip Arrays of Different Lengths"; init track)
  else(
    init track{chords = c; durations = f;key_sig = key_sig
              time_sig = time_sig; tempo = tempo}
  )
)

fun ZipDiff f c = (
  out_f = f
  out_c = c
  if (Size f) == 1 then(
    iter = Size c
    out_f = SameList f.(0) iter
  )
  else (
    iter = Size f
    out_c = SameList c.(0) iter
  )
  init track{chords = out_c; durations = out_f; key_sig = key_sig
              time_sig = time_sig; tempo = tempo}
)

fun Scale pitch_start pitch_end = (
  c = chord{}
  start = pitch_start$rank
  end = pitch_end$rank
  if start < end then (
    for x in Range start (end + 1) do 
      c = c . [x]
  )
  else (
    for x in Range end (start + 1) do
      c = [x] . c
  )
  c
)

fun Arpeggio chord = (
  chord$pitches
)

fun Rhythms track = (
  track$durations
)

fun Chords track = (
  track$chords
)

fun Parallel ts = (
  s = init song
  for t in ts do s$tracks = s$tracks . { {t} }
  s
)

fun Sequential ts = (
  init song { tracks = {ts} }
)

fun Length track = (
  length = 0.0
  for d in track$durations do length = length + d
  length
)

fun Extend length tr = (
  multiplier = length / Length tr
  // Add as many copies of the track as will fit
  orig_chords = tr$chords; orig_durations = tr$durations
  for i in Range 0 (IntOfFloat multiplier - 1) do (
    Ignore i
    tr$chords = tr$chords . orig_chords
    tr$durations = tr$durations . orig_durations
  )
  // Fill the rest of the space with a rest
  pad = length - Length tr
  if pad > 0.0 then (
    tr$chords = tr$chords . { (init chord) }
    tr$durations = tr$durations . [ pad ]
  ) else ()
  tr
)

fun StartWith tr base_track = (
  if((tr$key_sig != base_track$key_sig) || (tr$time_sig != base_track$time_sig)) then
    (throw "Cannot concat tracks with different key or time signature"; tr)
  else
    base_track . tr
)

fun EndWith track base_track = (
  StartWith base_track track
)

fun Reverse tr = (
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
  chords = (Reverse_List tr$chords); durations = (Reverse_List tr$durations)}
)

fun OctaveChordList shift ch = (
  rel_chords = chord{}
  for c in ch do
    rel_chords = rel_chords . {(AddChordNum (shift * Size key_sig$scale) c)}
  rel_chords
)

fun Relative shift tr = (
  rel_chords = chord{}
  for c in tr$chords do
    rel_chords = rel_chords . {(AddChordNum shift c)}
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
            chords = rel_chords; durations = tr$durations;}
)

fun Octave shift tr = (
  Relative (shift*(Size key_sig$scale)) tr
)

fun Repeat times tr = (
  if times <= 1 then
    tr
  else
    tr . Repeat (times - 1) tr
)

// TODO: volume mix functions for song objects

