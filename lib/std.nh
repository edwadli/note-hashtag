include array
include io
include math

extern "support.hpp" "nh_support" "int_of_float" fun IntOfFloat float -> int
extern "support.hpp" "std" "to_string" fun StringOfFloat float -> string

extern "support.hpp" "nh_support" "float_of_int" fun FloatOfInt int -> float
extern "support.hpp" "std" "to_string" fun StringOfInt int -> string

extern "support.hpp" "nh_support" "shuffle" fun ShuffleInts int{} -> int{}
extern "support.hpp" "nh_support" "shuffle" fun ShuffleFloats float{} -> float{}

type key_signature = {
  scale = { 261.63 293.66 329.63 349.23 392.00 440.00 493.88 }
}


type time_signature = {
  upper = 4
  lower = 4
}

type pitch = {
  rank = 1
  octave = 0
  offset = 0
}

type chord = {
  pitches = pitch{}
}

fun ChordOfPitch p = init chord { pitches = {p} }

fun PitchOfInt i = (
  if (i < 0) || (i > (Size key_sig$scale)) then (
    throw "Could not construct pitch from int";
    init pitch)
  else
    init pitch { rank = i }
)


fun AddPitchOctave p octaves = ( p$octave = p$octave + octaves; p)

fun AddPitchNum num p = (

  r = p$rank + num
  oct = 0
  size = Size key_sig$scale
  if r > size then (
    oct = r/size
    r = ((r-1) % size)
    r = r + 1 //edge case for r = 7
  )
  else
    ()
  init pitch{rank = r; octave = (oct + p$octave); offset = p$offset}
)

fun AddChordNum num ch = (
  out_pitch = pitch{}
  for p in ch$pitches do
    out_pitch = out_pitch . {(AddPitchNum num p)}
  init chord{pitches = out_pitch}
)

fun PrintChord ch = (
  size = Size ch
  for c in ch do (
    x = c$pitches
    for p in x do
      Print (StringOfInt p$rank)
    Print "\n"
  )
)

fun PrintRhythms rh = (
  size = Size rh
  for r in rh do (
    Print (StringOfFloat r)
  )
)


type track = {
  key_sig = init key_signature
  time_sig = init time_signature
  chords = chord{}
  durations = float{}
  // currently we can only assign a single volume to the track
  // of dynamics control we lack
  // yes, it's a simplicity hack
  // but i'd like to hit the sack
  volume = 1.0
}

type song = {
  tracks = track{}{}
  volumes = float{}
}

fun IsMember l x = (
  mem = false
  for item in l do mem = (mem || (item == x))
  mem
)

fun Reverse_List l = (
  size = Size l
  if size < 2 then
    l
  else (
    out = [(l.(size-1))];
    for i in Range 2 (size+1) do
      out = out . [l.(size - i)]
    out
  ) 
)

fun FlatPitch p = ( p$offset = p$offset - 1; p )
fun SharpPitch p = ( p$offset = p$offset + 1; p )

fun ChordOfChords c1 c2 = (
  c = init chord
  for p in c1$pitches . c2$pitches
    do if IsMember c$pitches p then () else c$pitches = c$pitches . {p}
  c
)

fun Rest = init chord

fun ConcatTracks t1 t2 = (
  if t1$key_sig == t2$key_sig &&\
      t1$time_sig == t2$time_sig
  then (
    t1$chords = t1$chords . t2$chords
    t1$durations = t1$durations . t2$durations
    t1
  )
  else (throw "Cannot concat tracks with different key or time signature"; t1)
)

key_sig = init key_signature
time_sig = init time_signature
tempo = 120

fun Scale pitch_start pitch_end = (
  c = chord{}
  start = pitch_start$rank
  end = pitch_end$rank
  if start < end then (
    for x in Range start (end + 1) do 
      c = c . [x]
  )
  else (
    for x in Range end (start + 1) do
      c = [x] . c
  )
  c
)

fun Arpeggio chord = (
  chord$pitches
)

fun Rhythms track = (
  track$durations
)

fun Chords track = (
  track$chords
)

/*
fun Parallel tracks = (
  // TODO: return song object with tracks aligned in parallel
)
*/

fun Sequential t = (
  init song { tracks = {t} }
)

fun Length track = (
  length = 0.0
  for d in track$durations do length = length + d
  length
)

fun Extend length tr = (
  track_length = Length tr
  repeat = IntOfFloat (length/track_length)
  pad = [(length - (FloatOfInt(repeat) * track_length))]
  i = 0
  out_chord = chord{}
  out_dur = float{}
  for i in Range 0 repeat do (
    out_chord = out_chord . t$chords
    out_dur = out_dur . t$durations)
  pad_chord = chord{} 
  if pad.(0) != 0.000000 then(
    out_chord = out_chord . pad_chord
    out_dur = out_dur . pad)
  else
    ()
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
             chords = out_chord; durations = out_dur}
             //want to zip in future
)

fun StartWith tr base_track = (
  if((tr$key_sig != base_track$key_sig) || (tr$time_sig != base_track$time_sig)) then
    (throw "Cannot concat tracks with different key or time signature"; tr)
  else
    base_track . tr
)

fun EndWith track base_track = (
  StartWith base_track track
)

fun Reverse tr = (
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
  chords = (Reverse_List tr$chords); durations = (Reverse_List tr$durations)}
)

fun OctaveChordList shift ch = (
  rel_chords = chord{}
  for c in ch do
    rel_chords = rel_chords . {(AddChordNum (shift * Size key_sig$scale) c)}
  rel_chords
)

fun Relative shift tr = (
  rel_chords = chord{}
  for c in tr$chords do
    rel_chords = rel_chords . {(AddChordNum shift c)}
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
            chords = rel_chords; durations = tr$durations;}
)

fun Octave shift tr = (
  Relative (shift*(Size key_sig$scale)) tr
)

fun Repeat times tr = (
  if times <= 1 then
    tr
  else
    tr . Repeat (times - 1) tr
)

// TODO: volume mix functions for song objects

