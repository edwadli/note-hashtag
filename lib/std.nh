include array
include io
include math

extern "support.hpp" "nh_support" "int_of_float" fun IntOfFloat float -> int
extern "support.hpp" "std" "to_string" fun StringOfFloat float -> string

extern "support.hpp" "nh_support" "float_of_int" fun FloatOfInt int -> float
extern "support.hpp" "std" "to_string" fun StringOfInt int -> string

extern "support.hpp" "nh_support" "shuffle" fun ShuffleInts int{} -> int{}
extern "support.hpp" "nh_support" "shuffle" fun ShuffleFloats float{} -> float{}

fun Ignore x = ()

const eighth = 0.125
const e = eighth
const quarter = 0.25
const q = quarter
const triplet = 1.0 / 3.0
const t = triplet
const half = 0.5
const h = 0.5
const whole = 1.0
const w = whole

type key_signature = {
  scale = { 261.63 293.66 329.63 349.23 392.00 440.00 493.88 }
}

type time_signature = {
  upper = 4
  lower = 4
}

type pitch = {
  rank = 1
  octave = 0
  offset = 0
}

type chord = {
  pitches = pitch{}
}

fun ChordOfPitch p = init chord { pitches = {p} }

fun PitchOfInt i = (
  if (i < 0) || (i > (Size key_sig$scale)) then (
    throw "Could not construct pitch from int";
    init pitch)
  else
    init pitch { rank = i }
)

fun NormalizePitch p keysig = (
  scale_size = Size keysig$scale
  if p$rank < 1 then (
    octave_offset = (-1 * p$rank) / scale_size + 1
    p$rank = p$rank + octave_offset * scale_size
    p$octave = p$octave - octave_offset
  ) else (
    p$rank = p$rank - 1 // Make normalization easier. Pitch is [1, 7] -> [0, 6]
    p$octave = p$octave + p$rank / scale_size
    p$rank = p$rank % scale_size
    p$rank = p$rank + 1 // Undo our change: [0, 6] -> [1, 7]
  )
  p
)

fun AddPitchOctave p octaves = ( p$octave = p$octave + octaves; p)

fun AddPitchNum num p keysig = (
  p$rank = p$rank + num
  NormalizePitch p keysig
)

fun AddChordNum num ch keysig = (
  out_pitch = pitch{}
  for p in ch$pitches do
    out_pitch = out_pitch . { (AddPitchNum num p keysig) }
  ch$pitches = out_pitch
  ch
)

fun PrintChord ch = (
  size = Size ch
  for c in ch do (
    x = c$pitches
    for p in x do
      Print (StringOfInt p$rank)
    Print "\n"
  )
)

fun PrintRhythms rh = (
  size = Size rh
  for r in rh do (
    Print (StringOfFloat r)
  )
)


type track = {
  key_sig = init key_signature
  time_sig = init time_signature
  tempo = 120
  chords = chord{}
  durations = float{}
  // currently we can only assign a single volume to the track
  // of dynamics control we lack
  // yes, it's a simplicity hack
  // but i'd like to hit the sack
  volume = 1.0
}

type song = {
  tracks = track{}{}
  volumes = float{}
}

fun IsMember l x = (
  mem = false
  for item in l do mem = (mem || (item == x))
  mem
)

fun Reverse_List l = (
  size = Size l
  if size < 2 then
    l
  else (
    out = [(l.(size-1))];
    for i in Range 2 (size+1) do
      out = out . [l.(size - i)]
    out
  ) 
)

fun FlatPitch p = ( p$offset = p$offset - 1; p )
fun SharpPitch p = ( p$offset = p$offset + 1; p )

fun ChordOfChords c1 c2 = (
  c = init chord
  for p in c1$pitches . c2$pitches
    do if IsMember c$pitches p then () else c$pitches = c$pitches . {p}
  c
)

fun Rest = init chord

fun ConcatTracks t1 t2 = (
  if t1$key_sig == t2$key_sig &&\
      t1$time_sig == t2$time_sig &&\
      t1$tempo == t2$tempo
  then (
    t1$chords = t1$chords . t2$chords
    t1$durations = t1$durations . t2$durations
    t1
  )
  else (throw "Cannot concat tracks with different key or time signature or tempo"; t1)
)

key_sig = init key_signature
time_sig = init time_signature
tempo = 120

fun ZipSame f c = (
  if (Size f) != (Size c) then
    (throw "Cannot Zip Arrays of Different Lengths"; init track)
  else(
    init track{chords = c; durations = f;key_sig = key_sig
              time_sig = time_sig; tempo = tempo}
  )
)

fun ZipDiff f c = (
  out_f = f
  out_c = c
  if (Size f) == 1 then(
    iter = Size c
    out_f = SameList f.(0) iter
  )
  else (
    iter = Size f
    out_c = SameList c.(0) iter
  )
  init track{chords = out_c; durations = out_f; key_sig = key_sig
              time_sig = time_sig; tempo = tempo}
)

fun Scale pitch_start pitch_end = (
  c = chord{}
  start = pitch_start$rank
  end = pitch_end$rank
  if start < end then (
    for x in Range start (end + 1) do 
      c = c . [x]
  )
  else (
    for x in Range end (start + 1) do
      c = [x] . c
  )
  c
)

extern "support.hpp" "nh_support" "render_impl" fun RenderImpl float{}{}{} float{}{} float{} string -> unit

fun Render song filename = (
  if Size song$tracks != Size song$volumes then throw "Internal error: song has mismatched tracks and volumes" else ()
  freqs = float{}{}{}
  durs = float{}{}
  for track_chan in song$tracks do (
    freq_chan = float{}{}
    dur_chan = float{}
    for track in track_chan do (
      freq_chan = freq_chan . FrequenciesOfChords track$chords track$key_sig
      dur_chan = dur_chan . SecondsOfDurations track$durations track$time_sig track$tempo
    )
    freqs = freqs . { freq_chan }
    durs = durs . { dur_chan }
  )
  RenderImpl freqs durs song$volumes filename
)

fun FrequencyOfPitch pitch keysig = (
  if pitch$offset != 0 then PrintEndline "warning: pitch offset not supported right now" else ()
  pitch$rank = pitch$rank - 1
  keysig$scale.(pitch$rank) * Pow 2.0 (FloatOfInt pitch$octave)
)

fun FrequenciesOfChord chord keysig = (
  if Size chord$pitches == 0 then { 0.0 }
  else (
    freqs = float{}
    for pitch in chord$pitches do (
      freqs = freqs . { (FrequencyOfPitch pitch keysig) }
    )
    freqs
  )
)

fun FrequenciesOfChords chords keysig = (
  freqs = float{}{}
  for chord in chords do (
    freqs = freqs . { (FrequenciesOfChord chord keysig) }
  )
  freqs
)

fun SecondsOfDurations durations timesig tempo = (
  multiplier = FloatOfInt timesig$lower * 60.0 / FloatOfInt tempo
  seconds = float{}
  for duration in durations do (
    seconds = seconds . { (duration * multiplier) }
  )
  seconds
)

fun Arpeggio chord = (
  chord$pitches
)

fun Rhythms track = (
  track$durations
)

fun Chords track = (
  track$chords
)

fun Parallel ts = (
  s = init song
  for t in ts do (
    s$tracks = s$tracks . { {t} }
    s$volumes = s$volumes . { 1.0 }
  )
  s
)

fun Sequential ts = (
  init song { tracks = {ts} }
)

fun Length track = (
  length = 0.0
  for d in track$durations do length = length + d
  length
)

fun Extend length tr = (
  multiplier = length / Length tr
  // Add as many copies of the track as will fit
  orig_chords = tr$chords; orig_durations = tr$durations
  for i in Range 0 (IntOfFloat multiplier - 1) do (
    Ignore i
    tr$chords = tr$chords . orig_chords
    tr$durations = tr$durations . orig_durations
  )
  // Fill the rest of the space with a rest
  pad = length - Length tr
  if pad > 0.0 then (
    tr$chords = tr$chords . { (init chord) }
    tr$durations = tr$durations . [ pad ]
  ) else ()
  tr
)

fun StartWith tr base_track = (
  if((tr$key_sig != base_track$key_sig) || (tr$time_sig != base_track$time_sig)) then
    (throw "Cannot concat tracks with different key or time signature"; tr)
  else
    base_track . tr
)

fun EndWith track base_track = (
  StartWith base_track track
)

fun Reverse tr = (
  init track{time_sig = tr$time_sig; key_sig = tr$key_sig;
  chords = (Reverse_List tr$chords); durations = (Reverse_List tr$durations)}
)

fun OctaveChordList shift ch = (
  rel_chords = chord{}
  for c in ch do
    rel_chords = rel_chords . {(AddChordNum (shift * Size key_sig$scale) c key_sig)}
  rel_chords
)

fun Relative shift tr = (
  rel_chords = chord{}
  for c in tr$chords do
    rel_chords = rel_chords . {(AddChordNum shift c tr$key_sig)}
  tr$chords = rel_chords
  tr
)

fun Octave shift tr = (
  Relative (shift*(Size tr$key_sig$scale)) tr
)

fun Repeat times tr = (
  if times <= 1 then
    tr
  else
    tr . Repeat (times - 1) tr
)

// TODO: volume mix functions for song objects

