extern "support.hpp" "nh_support" "print_string" fun Print string -> unit

fun PrintEndline str = (
  Print str
  Print "\n"
)

extern "support.hpp" "nh_support" "int_of_float" fun IntOfFloat float -> int
extern "support.hpp" "std" "to_string" fun StringOfFloat float -> string

extern "support.hpp" "nh_support" "float_of_int" fun FloatOfInt int -> float
extern "support.hpp" "std" "to_string" fun StringOfInt int -> string

extern "support.hpp" "std" "pow" fun Pow float float -> float

extern "support.hpp" "nh_support" "shuffle" fun ShuffleInts int{} -> int{}
extern "support.hpp" "nh_support" "shuffle" fun ShuffleFloats float{} -> float{}

type key_signature = {
  scale = { 261.63 293.66 329.63 349.23 392.00 440.00 493.88 }
}


type time_signature = {
  upper = 4
  lower = 4
}

type pitch = {
  rank = 1
  octave = 0
  offset = 0
}


type chord = {
  pitches = pitch{}
}

fun ChordOfPitch pitch = init chord { pitches = {pitch} }

fun PitchOfInt i = (
  if (i < 0) || (i > (Size key_sig$scale)) then (
    throw "Could not construct pitch from int";
    init pitch)
  else
    init pitch { rank = i }
)

fun AddPitchOctave pitch octaves = ( pitch$octave = pitch$octave + octaves; pitch )


type track = {
  key_sig = init key_signature
  time_sig = init time_signature
  chords = chord{}
  durations = float{}
  // currently we can only assign a single volume to the track
  // of dynamics control we lack
  // yes, it's a simplicity hack
  // but i'd like to hit the sack
  volume = 1.0
}

type song = {
  tracks = track{}{}
  volumes = float{}
}


fun Size l = (
  i = 0
  for item in l do i = i + 1
  i
)

fun IsMember l x = (
  mem = false
  for item in l do mem = (mem || (item == x))
  mem
)

fun Range i j = (
  if j < i then
    int{}
  else
    {i} . (Range (i+1) j)
)


fun FlatPitch pitch = ( pitch$offset = pitch$offset - 1; pitch )
fun SharpPitch pitch = ( pitch$offset = pitch$offset + 1; pitch )

fun ChordOfChords c1 c2 = (
  c = chord{}
  for pitch in c1$pitches . c2$pitches
    do if IsMember c pitch then () else c = c . {pitch}
  c
)

fun Rest = init chord

fun ConcatTracks t1 t2 = (
  if t1$key_sig == t2$key_sig &&\
      t1$time_sig == t2$time_sig
  then (
    t1$chords = t1$chords . t2$chords
    t1$durations = t1$durations . t2$durations
    t1
  )
  else (throw "Cannot concat tracks with different key or time signature"; t1)
)

key_sig = init key_signature
time_sig = init time_signature
tempo = 120

fun Scale pitch_start pitch_end = (
  c = chord{}
  start = pitch_start$rank
  end = pitch_end$rank
  x = Range start end
  if start < end then (
    for x in Range start end do 
      c = c . [x]
  )
  else (
    for x in Range end start do
      c = [x] . c
  )
  c
)

/*

fun Arpeggio chord = (
  p = chord$pitches
  // TODO: unpack chord into music array
)


fun Rhythms track = (
  // TODO: get rhythm from track
)


fun Chords track = (
  // TODO: get chords from track
)


fun Parallel tracks = (
  // TODO: return song object with tracks aligned in parallel
)


fun Sequential tracks = (
  // TODO: return song object with tracks aligned sequentially
)

fun Length track = (
  // TODO: return length of track in terms of duration
)

fun Extend length track = (
  // TODO: repeat track for up to length duration
)

fun StartWith track base_track = (
  
)

fun EndWith track base_track = (

)

fun Reverse track = (

)

fun Relative shift track = (

)

fun Octave shift track = (

)

fun Repeat times track = (

)

// TODO: volume mix functions for song objects

*/
